/// last updated: 2025-10-26

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Basic helpers
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && (
        request.auth.uid == userId
        || (request.auth.token.phone_number != null && request.auth.token.phone_number == userId)
      );
    }

    // Allow a user document to be read publicly when the user is a registered worker
    // or when there's a separate /workers/$(userId) document. This permits showing
    // assigned worker's public contact info (phone, name) in order details pages
    // while keeping full profile edits restricted.
    function isWorkerProfilePublic(userId) {
      return (resource.data.role == 'worker') || exists(/databases/$(database)/documents/workers/$(userId));
    }

    // Admin detection: prefer custom claim, fall back to users/{uid}.role == 'admin'
    function isAdmin() {
      return isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
      );
    }

    function isWorker() {
      return isSignedIn() && (
        (request.auth.token != null && request.auth.token.role == 'worker')
        || exists(/databases/$(database)/documents/workers/$(request.auth.uid))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'worker')
      );
    }

    // Do not allow clients to set server-managed fields except when equal to request.time
    function allowedServerTimestamp(fieldName) {
      // Allow if the field is not being written, or the client is explicitly setting it to
      // the server timestamp (request.time), or the client is leaving the existing value
      // unchanged during an update. This permits updates that don't modify createdAt/updatedAt.
      return !(fieldName in request.resource.data)
             || request.resource.data[fieldName] == request.time
             || (resource.data[fieldName] == request.resource.data[fieldName]);
    }

    function noServerFields() {
      // For server-managed fields, allow the request when the client is not including
      // them, or when they are left unchanged (equal to the existing resource value).
      return (
        ( !('orderNumber' in request.resource.data) || request.resource.data.orderNumber == resource.data.orderNumber )
        && ( !('assignmentHistory' in request.resource.data) || request.resource.data.assignmentHistory == resource.data.assignmentHistory )
        && ( !('paymentRef' in request.resource.data) || request.resource.data.paymentRef == resource.data.paymentRef )
        && allowedServerTimestamp('createdAt')
        && allowedServerTimestamp('updatedAt')
      );
    }

    // -----------------------
    // users collection
    // -----------------------
    match /users/{userId} {
      allow create: if isSignedIn() && isOwner(userId) && noServerFields();

      // Allow reads for the owner, or when the requester has an admin claim,
      // or when the requester's users/{uid} doc contains role == 'admin'.
      // Also allow read when the target user is a worker so the client can
      // display assigned worker contact details in order pages. This keeps
      // full write/update protections intact.
      allow read: if isSignedIn() && (
        isOwner(userId)
        || (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        || isWorkerProfilePublic(userId)
      );

      allow update: if isSignedIn() && (
        // Allow updates by admin (via token or user doc role) or the owner with restrictions
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        || (
          isOwner(userId)
          && ( !('role' in request.resource.data) || request.resource.data.role == resource.data.role )
          && noServerFields()
        )
      );

      allow delete: if isSignedIn() && (
        isOwner(userId)
        || (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
      );

      // users/{uid}/orders subcollection
      match /orders/{orderId} {
        allow create: if isSignedIn()
          && isOwner(userId)
          && noServerFields()
          && ('items' in request.resource.data)
          && ('totalAmount' in request.resource.data);

        allow get: if isSignedIn() && (
          isOwner(userId)
          || (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
          || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
          || (isWorker() && (resource.data.workerId == request.auth.uid || resource.data.status == 'pending'))
        );

        allow list: if isSignedIn() && (
          // Allow listing only for admins or the owner of this user's orders.
          // Clients should query the per-user subcollection `users/{uid}/orders` when
          // listing a user's orders. Avoid inspecting request.query here because
          // the rules engine in this environment does not support request.query.where().
          (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
          || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
          || isOwner(userId)
          // Allow workers to list orders that are assigned to them by letting the
          // rules engine verify that each returned document has workerId == auth.uid.
          || (isWorker() && resource.data.workerId == request.auth.uid)
        );

        // Allow the owner to perform normal updates but forbid changing
        // `workerId` or `status`. Permit owners to add rating-related fields
        // (e.g. `rated`, `serviceRated`, `workerRated`, `rating`, `ratingAt`) as
        // long as the payload does not touch protected fields.
        allow update: if isSignedIn() && (
           // Admins can update any order
           (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
           || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
           || (
             isOwner(userId)
             && !( 'workerId' in request.resource.data )
             && !( 'status' in request.resource.data )
             // Disallow clients from overwriting server-managed identifiers/timestamps
             // but allow adding rating flags/fields.
             && !( 'orderNumber' in request.resource.data )
             && !( 'assignmentHistory' in request.resource.data )
             && !( 'paymentRef' in request.resource.data )
             && !( 'createdAt' in request.resource.data )
             && !( 'updatedAt' in request.resource.data )
           )
           // Narrow explicit branch: allow the existing order owner to submit rating fields
           // even when other update checks fail. This only permits a tightly-scoped set
           // of keys to be written and requires the existing document to belong to the caller.
           || (
             isSignedIn()
             && isOwner(userId)
             // Validate rating payloads using helper to ensure types and ranges.
             && isValidOrderRatingPayload()
           )
        );

        allow delete: if isSignedIn() && (
          (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
          || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        );
      }

      // users/{uid}/payments subcollection
      match /payments/{paymentId} {
        allow create: if isSignedIn() && isOwner(userId) && noServerFields();
        allow read: if isSignedIn() && (isOwner(userId) || isAdmin());
        allow update: if isSignedIn() && (isAdmin() || (isOwner(userId) && noServerFields()));
        allow delete: if isSignedIn() && isAdmin();
      }

      // users/{uid}/cart subcollection
      match /cart/{cartId} {
        allow read, write: if isSignedIn() && (isOwner(userId) || isAdmin());
      }
    }

    // -----------------------
    // workers collection
    // -----------------------
    match /workers/{workerId} {
      allow create: if isSignedIn() && (isAdmin() || isOwner(workerId)) && noServerFields();
      // Allow authenticated users to read worker public profiles (name, phone, avatar).
      // Updates/removal remain restricted to admin or the worker owner.
      allow read: if isSignedIn();
      allow update: if isSignedIn() && (isAdmin() || isOwner(workerId)) && noServerFields();
      allow delete: if isSignedIn() && isAdmin();

      // Per-worker ratings subcollection: clients may create ratings for assigned workers.
      match /ratings/{ratingId} {
        // Accept rating docs that either set `createdAt` to server time or omit it
        // (client can use FieldValue.serverTimestamp()).
        allow create: if isSignedIn()
          && request.resource.data.keys().hasOnly(['workerId','orderId','orderNumber','userId','rating','review','createdAt','remoteId'])
          && request.resource.data.workerId == workerId
          && request.resource.data.userId == request.auth.uid
          && (request.resource.data.rating is number)
          && request.resource.data.rating >= 1
          && request.resource.data.rating <= 5
          && ( !('createdAt' in request.resource.data) || request.resource.data.createdAt == request.time );

        allow read: if true;
        allow update, delete: if isSignedIn() && isAdmin();
      }
    }

    // Per-worker assigned orders mirror. Use a trusted server/Cloud Function to
    // copy/keep in sync assignments from /orders or /users/{uid}/orders into
    // /workers/{workerId}/orders so workers can safely list their assignments.
    match /workers/{workerId}/orders/{orderId} {
      // Workers (and admins) can list/get their assigned orders here.
      allow get, list: if isSignedIn() && (isAdmin() || request.auth.uid == workerId);

      // Allow updates by admin, or by the assigned worker with the same
      // limited status transitions and no server-managed field modifications.
      allow update: if isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (
          request.auth.uid == workerId
          && noServerFields()
          && (
            ( 'status' in request.resource.data && (
                request.resource.data.status in ['accepted', 'on_my_way', 'arrived', 'in_progress', 'paused', 'completed']
                && resource.data.status != 'completed'
              ) && request.resource.data.workerId == resource.data.workerId)
            || ( !('status' in request.resource.data) )
          )
        )
      );

      // Creation/deletion should be performed only by admin/trusted backend.
      allow create, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // services collection
    // -----------------------
    match /services/{serviceId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();

      // Per-service ratings subcollection: clients may create ratings entries.
      match /ratings/{ratingId} {
        // Allow anyone signed-in to create a rating for the service, provided
        // the payload is well-formed and the userId matches the authenticated user.
        // Accept rating docs that either set `createdAt` to server time or omit it
        // (client can use FieldValue.serverTimestamp()).
        allow create: if isSignedIn()
          && request.resource.data.keys().hasOnly(['serviceId','orderId','orderNumber','userId','rating','review','createdAt','remoteId'])
          && request.resource.data.serviceId == serviceId
          && request.resource.data.userId == request.auth.uid
          && (request.resource.data.rating is number)
          && request.resource.data.rating >= 1
          && request.resource.data.rating <= 5
          && ( !('createdAt' in request.resource.data) || request.resource.data.createdAt == request.time );

        // Allow read publicly so service pages can show ratings.
        allow read: if true;

        // Only admins may update or delete rating documents (for moderation).
        allow update, delete: if isSignedIn() && isAdmin();
      }
    }

    // -----------------------
    // top-level orders collection
    // -----------------------
    match /orders/{orderId} {
      allow get: if isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        || (resource.data.orderOwner == request.auth.uid)
        || (resource.data.userId == request.auth.uid)
        || (isWorker() && (resource.data.workerId == request.auth.uid || resource.data.status == 'pending'))
      );

      allow list: if isSignedIn() && (
        // Top-level orders listing is restricted to admins only. Regular users
        // must list their orders from `users/{uid}/orders` to avoid exposing
        // other users' orders. This also avoids using unsupported request.query.where().
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        // Allow workers to query top-level orders filtered by workerId==auth.uid
        || (isWorker() && resource.data.workerId == request.auth.uid)
        // Allow owners to list their own orders when the query filters by orderOwner/userId
        // (e.g. where('orderOwner', '==', request.auth.uid) ). This keeps top-level
        // listing restricted while permitting a common client pattern.
        || (resource.data.orderOwner == request.auth.uid)
        || (resource.data.userId == request.auth.uid)
      );

      allow create: if isSignedIn() && noServerFields() && ('items' in request.resource.data) && ('totalAmount' in request.resource.data);

      allow update: if isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        || ((resource.data.orderOwner == request.auth.uid || resource.data.orderOwner == request.auth.token.phone_number)
            && !( 'workerId' in request.resource.data )
            && !( 'status' in request.resource.data )
            && noServerFields())
        || (
          // Allow assigned worker to update top-level order even if `isWorker()` is false
          resource.data.workerId == request.auth.uid
          && noServerFields()
          && (
            ( 'status' in request.resource.data && (
                request.resource.data.status in ['accepted', 'on_my_way', 'arrived', 'in_progress', 'paused', 'completed']
                && resource.data.status != 'completed'
              ) && request.resource.data.workerId == resource.data.workerId)
            || ( !('status' in request.resource.data) && !('workerId' in request.resource.data) )
          )
        )
        // Narrow fallback: allow assigned worker to perform a minimal, safe status-only update
        // even if other checks fail â€” only for the exact fields below and permitted values.
        || (
          isSignedIn()
          && resource.data.workerId == request.auth.uid
          // allow updatedAt as well (client may send serverTimestamp)
          // Accept either payloads that include workerId or that omit it (status-only)
          && (
            request.resource.data.keys().hasOnly(['status','orderStatus','workerId','updatedAt'])
            || request.resource.data.keys().hasOnly(['status','orderStatus','updatedAt'])
          )
          // if workerId is provided, ensure it matches the existing value
          && ( !('workerId' in request.resource.data) || request.resource.data.workerId == resource.data.workerId )
          && request.resource.data.status in ['accepted', 'on_my_way', 'arrived', 'in_progress', 'paused', 'completed']
          && resource.data.status != 'completed'
          // ensure updatedAt is either not written or is a server timestamp or unchanged
          && allowedServerTimestamp('updatedAt')
        )
        // Allow the order owner to submit rating fields on the top-level order with validation
        || (
          isSignedIn()
          && (resource.data.orderOwner == request.auth.uid || resource.data.userId == request.auth.uid || resource.data.orderOwner == request.auth.token.phone_number)
          && isValidOrderRatingPayload()
        )
      );

      allow delete: if isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
      );
    }

    // -----------------------
    // bookings, payments, offers, admins, audit_logs, etc.
    // replicate admin/owner semantics similar to above.
    // -----------------------
    match /bookings/{bookingId} {
      allow create: if isSignedIn() && noServerFields() && (
        request.resource.data.orderOwner == request.auth.uid
        || request.resource.data.userId == request.auth.uid
        || (request.auth.token.phone_number != null && (request.resource.data.orderOwner == request.auth.token.phone_number || request.resource.data.userId == request.auth.token.phone_number))
      );

      // Use resource.data (existing document) for reads.
      allow get: if isSignedIn() && (
        isAdmin()
        || resource.data.orderOwner == request.auth.uid
        || resource.data.userId == request.auth.uid
        || (request.auth.token.phone_number != null && (resource.data.orderOwner == request.auth.token.phone_number || resource.data.userId == request.auth.token.phone_number))
      );
      // Restrict listing bookings at top-level to admins; users should list their
      // bookings via a per-user subcollection if available.
      allow list: if isSignedIn() && isAdmin();
      // For updates, check ownership on the existing document (resource.data)
      // and still require noServerFields() on the incoming data.
      allow update: if isSignedIn() && (
        isAdmin()
        || (
          (resource.data.orderOwner == request.auth.uid
           || resource.data.userId == request.auth.uid
           || (request.auth.token.phone_number != null && (resource.data.orderOwner == request.auth.token.phone_number || resource.data.userId == request.auth.token.phone_number))
          )
          && noServerFields()
        )
      );
      allow delete: if isSignedIn() && isAdmin();
    }

    match /offers/{offerId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    match /payments/{paymentId} {
      allow read: if isSignedIn() && (isAdmin() || (resource.data.orderOwner == request.auth.uid) || (resource.data.userId == request.auth.uid) || (request.auth.token.phone_number != null && (resource.data.userId == request.auth.token.phone_number || resource.data.orderOwner == request.auth.token.phone_number)));
      allow create: if isSignedIn() && noServerFields() && ('amount' in request.resource.data || 'totalAmount' in request.resource.data);
      allow update: if isSignedIn() && (isAdmin() || ((resource.data.userId == request.auth.uid || resource.data.orderOwner == request.auth.uid) && noServerFields()));
      allow delete: if isSignedIn() && isAdmin();
    }

    match /admins/{adminId} {
      allow read: if isSignedIn() && isAdmin();
      allow create: if isSignedIn() && (isAdmin() || (request.auth.uid == adminId && exists(/databases/$(database)/documents/users/$(adminId)) && get(/databases/$(database)/documents/users/$(adminId)).data.role == 'admin'));
      allow update, delete: if isSignedIn() && isAdmin();
    }

    match /audit_logs/{logId} {
      allow read, create, update, delete: if isSignedIn() && isAdmin();
    }

    // Appointments collection: stores scheduled appointments linked to orders
    match /appointments/{appointmentId} {
      // Creation should be performed by admins/trusted backend only.
      allow create: if isSignedIn()
        && isAdmin()
        // payload keys allowed
        && request.resource.data.keys().hasOnly(['orderId','userId','workerId','scheduledAt','status','notes','createdAt','updatedAt'])
        // basic type checks
        && (request.resource.data.orderId is string)
        && (request.resource.data.workerId is string)
        && (request.resource.data.scheduledAt is timestamp)
        // scheduledAt must be in the future or present (no past appointments)
        && (request.resource.data.scheduledAt >= request.time)
         // createdAt may be omitted or set to server time
         && ( !('createdAt' in request.resource.data) || request.resource.data.createdAt == request.time );

      // Allow admins, the assigned worker, or the order owner to read an appointment
      allow get: if isSignedIn() && (
        isAdmin()
        || (resource.data.userId == request.auth.uid)
        || (resource.data.workerId == request.auth.uid)
      );

      // Allow listing for admins; workers may list their own appointments via a query
      allow list: if isSignedIn() && (
        isAdmin()
        || isWorker()
      );

      // Allow limited updates: admins can do anything; assigned worker may update status/startAt/endAt
      allow update: if isSignedIn() && (
        isAdmin()
        || (
          isWorker()
          && resource.data.workerId == request.auth.uid
          // Restrict keys a worker may update on-their-appointment
          && request.resource.data.keys().hasOnly(['status','startAt','endAt','notes','updatedAt'])
          // Ensure status is one of the allowed values when provided
          && (
            !( 'status' in request.resource.data )
            || (request.resource.data.status in ['scheduled','confirmed','rescheduled','cancelled','completed'])
          )
          // startAt/endAt must be timestamps when present
          && ( !('startAt' in request.resource.data) || request.resource.data.startAt is timestamp )
          && ( !('endAt' in request.resource.data) || request.resource.data.endAt is timestamp )
          // updatedAt must be server timestamp or unchanged
          && allowedServerTimestamp('updatedAt')
        )
      );

      // Only admin may delete appointment documents
      allow delete: if isSignedIn() && isAdmin();
    }

    // Deny by default
    match /{document=**} {
      allow read, write: if false;
    }

    // Generic match to allow collectionGroup queries on any `orders` subcollection
    match /{path=**}/orders/{orderId} {
      allow get: if isSignedIn() && (
        isAdmin()
        || resource.data.orderOwner == request.auth.uid
        || resource.data.userId == request.auth.uid
        || (isWorker() && (resource.data.workerId == request.auth.uid || resource.data.status == 'pending'))
      );

      // Allow listing via collectionGroup only for admins or workers when the
      // returned documents are assigned to the worker (the query must include
      // where('workerId', '==', request.auth.uid) for this to be secure and
      // supported by the rules engine).
      allow list: if isSignedIn() && (
        isAdmin()
        || (isWorker() && resource.data.workerId == request.auth.uid)
      );
    }

    // -----------------------
    // order_counters collection (daily incrementing counter used to generate order numbers)
    // Clients need to run a transaction on a per-day document `order_counters/{YYYYMMDD}`
    // to reserve the next sequence number. The rules below permit authenticated
    // clients to create the day's document with seq==1, or to increment an
    // existing document's seq by exactly +1, and only allow the fields `seq`
    // and `updatedAt` to be written. This limits abuse while allowing the
    // client-side `runTransaction` in `generateOrderNumber()` to succeed.
    match /order_counters/{counterId} {
      // Allow reads for authenticated clients (optional; useful for debugging)
      allow get, list: if isSignedIn();

      // Allow create only when the request provides exactly the allowed fields
      // and initializes the sequence to 1 and uses server time for updatedAt.
      allow create: if isSignedIn()
        && request.resource.data.keys().hasOnly(['seq','updatedAt'])
        && (request.resource.data.seq is int) && request.resource.data.seq == 1
        // updatedAt must be set to request.time (clients may send request.time when using serverTimestamp)
        && (request.resource.data.updatedAt == request.time);

      // Allow update only when the request increments seq by exactly 1 and
      // doesn't write any other fields. Also require updatedAt to be request.time.
      allow update: if isSignedIn()
        && resource.data.keys().hasAny(['seq'])
        && request.resource.data.keys().hasOnly(['seq','updatedAt'])
        && (request.resource.data.seq is int)
        // only allow increment-by-one updates
        && (request.resource.data.seq == (resource.data.seq + 1))
        && (request.resource.data.updatedAt == request.time);

      // Deletes are not allowed from clients
      allow delete: if false;
    }

    // Allow users to create a temporary pending profile before email verification.
    // This collection is used by the client to store registration data until
    // the user verifies their email and a full profile is created in /users.
    match /pending_profiles/{userId} {
      allow create: if isSignedIn() && request.auth.uid == userId && noServerFields();
      allow read: if isSignedIn() && request.auth.uid == userId;
      // Allow delete by owner or admin (cleanup after profile creation)
      allow delete: if isSignedIn() && (request.auth.uid == userId || isAdmin());
      // Prevent direct updates from clients; prefer delete+create or server-side flows.
      allow update: if false;
    }

    // -----------------------
    // Custom functions (rating helpers)
    // -----------------------
    // Helper: validate a simple scalar rating (1..5)
    function isValidRatingValue(val) {
      return (val is number) && val >= 1 && val <= 5;
    }

    // Helper: validate order-level rating payloads written by the order owner.
    // Implemented as a single boolean expression (no imperative `if` statements).
    function isValidOrderRatingPayload() {
      return request.resource.data.keys().hasOnly(['serviceRating','workerRating','rating','review','rated','ratingAt','remoteId'])
        && ( !('rating' in request.resource.data) || isValidRatingValue(request.resource.data.rating) )
        && ( !('serviceRating' in request.resource.data) || isValidRatingValue(request.resource.data.serviceRating) )
        && ( !('workerRating' in request.resource.data) || isValidRatingValue(request.resource.data.workerRating) )
        && ( !('review' in request.resource.data) || (request.resource.data.review is string) )
        && ( !('ratingAt' in request.resource.data) || request.resource.data.ratingAt == request.time )
        && ( !('rated' in request.resource.data) || (request.resource.data.rated is bool) );
    }
  }
}
