/// last updated: 2025-10-18

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Basic helpers
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && (
        request.auth.uid == userId
        || (request.auth.token.phone_number != null && request.auth.token.phone_number == userId)
      );
    }

    // Admin detection: prefer custom claim, fall back to users/{uid}.role == 'admin'
    function isAdmin() {
      return isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
      );
    }

    function isWorker() {
      return isSignedIn() && (
        (request.auth.token != null && request.auth.token.role == 'worker')
        || exists(/databases/$(database)/documents/workers/$(request.auth.uid))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'worker')
      );
    }

    // Do not allow clients to set server-managed fields except when equal to request.time
    function allowedServerTimestamp(fieldName) {
      // Allow if the field is not being written, or the client is explicitly setting it to
      // the server timestamp (request.time), or the client is leaving the existing value
      // unchanged during an update. This permits updates that don't modify createdAt/updatedAt.
      return !(fieldName in request.resource.data)
             || request.resource.data[fieldName] == request.time
             || (resource.data[fieldName] == request.resource.data[fieldName]);
    }

    function noServerFields() {
      // For server-managed fields, allow the request when the client is not including
      // them, or when they are left unchanged (equal to the existing resource value).
      return (
        ( !('orderNumber' in request.resource.data) || request.resource.data.orderNumber == resource.data.orderNumber )
        && ( !('assignmentHistory' in request.resource.data) || request.resource.data.assignmentHistory == resource.data.assignmentHistory )
        && ( !('paymentRef' in request.resource.data) || request.resource.data.paymentRef == resource.data.paymentRef )
        && allowedServerTimestamp('createdAt')
        && allowedServerTimestamp('updatedAt')
      );
    }

    // -----------------------
    // users collection
    // -----------------------
    match /users/{userId} {
      allow create: if isSignedIn() && isOwner(userId) && noServerFields();

      // Allow reads for the owner, or when the requester has an admin claim,
      // or when the requester's users/{uid} doc contains role == 'admin'.
      allow read: if isSignedIn() && (
        isOwner(userId)
        || (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
      );

      allow update: if isSignedIn() && (
        // Allow updates by admin (via token or user doc role) or the owner with restrictions
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        || (
          isOwner(userId)
          && ( !('role' in request.resource.data) || request.resource.data.role == resource.data.role )
          && noServerFields()
        )
      );

      allow delete: if isSignedIn() && (
        isOwner(userId)
        || (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
      );

      // users/{uid}/orders subcollection
      match /orders/{orderId} {
        allow create: if isSignedIn()
          && isOwner(userId)
          && noServerFields()
          && ('items' in request.resource.data)
          && ('totalAmount' in request.resource.data);

        allow get: if isSignedIn() && (
          isOwner(userId)
          || (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
          || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
          || (isWorker() && (resource.data.workerId == request.auth.uid || resource.data.status == 'pending'))
        );

        allow list: if isSignedIn() && (
          // Allow listing only for admins or the owner of this user's orders.
          // Clients should query the per-user subcollection `users/{uid}/orders` when
          // listing a user's orders. Avoid inspecting request.query here because
          // the rules engine in this environment does not support request.query.where().
          (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
          || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
          || isOwner(userId)
          // Allow workers to list orders that are assigned to them by letting the
          // rules engine verify that each returned document has workerId == auth.uid.
          || (isWorker() && resource.data.workerId == request.auth.uid)
        );

        allow update: if isSignedIn() && (
          // Admins can update any order
          (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
          || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
          || (
            isOwner(userId)
            && !( 'workerId' in request.resource.data )
            && !( 'status' in request.resource.data )
            && noServerFields()
          )
          || (
            // Allow assigned worker to update order even if `isWorker()` is false
            // (covers cases where auth token lacks role claim or a /workers doc isn't present).
            resource.data.workerId == request.auth.uid
            && noServerFields()
            // allow only limited status updates by the worker to a controlled set
            && (
              ( 'status' in request.resource.data && (
                  // worker may update status to one of these states provided the order is not already completed
                  request.resource.data.status in ['accepted', 'on_my_way', 'arrived', 'in_progress', 'paused', 'completed']
                  && resource.data.status != 'completed'
                ) && request.resource.data.workerId == resource.data.workerId)
              || ( !('status' in request.resource.data) && !('workerId' in request.resource.data) )
            )
          )
          // Narrow fallback: allow assigned worker to perform a minimal, safe status-only update
          // even if other checks fail â€” only for the exact fields below and permitted values.
          || (
            isSignedIn()
            && resource.data.workerId == request.auth.uid
            // allow updatedAt as well (client may send serverTimestamp)
            // Accept either payloads that include workerId or that omit it (status-only)
            && (
              request.resource.data.keys().hasOnly(['status','orderStatus','workerId','updatedAt'])
              || request.resource.data.keys().hasOnly(['status','orderStatus','updatedAt'])
            )
            // if workerId is provided, ensure it matches the existing value
            && ( !('workerId' in request.resource.data) || request.resource.data.workerId == resource.data.workerId )
            && request.resource.data.status in ['accepted', 'on_my_way', 'arrived', 'in_progress', 'paused', 'completed']
            && resource.data.status != 'completed'
            // ensure updatedAt is either not written or is a server timestamp or unchanged
            && allowedServerTimestamp('updatedAt')
          )
        );

        allow delete: if isSignedIn() && (
          (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
          || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        );
      }

      // users/{uid}/payments subcollection
      match /payments/{paymentId} {
        allow create: if isSignedIn() && isOwner(userId) && noServerFields();
        allow read: if isSignedIn() && (isOwner(userId) || isAdmin());
        allow update: if isSignedIn() && (isAdmin() || (isOwner(userId) && noServerFields()));
        allow delete: if isSignedIn() && isAdmin();
      }

      // users/{uid}/cart subcollection
      match /cart/{cartId} {
        allow read, write: if isSignedIn() && (isOwner(userId) || isAdmin());
      }
    }

    // -----------------------
    // workers collection
    // -----------------------
    match /workers/{workerId} {
      allow create: if isSignedIn() && (isAdmin() || isOwner(workerId)) && noServerFields();
      allow read: if isSignedIn() && (isAdmin() || isWorker() || isOwner(workerId));
      allow update: if isSignedIn() && (isAdmin() || isOwner(workerId)) && noServerFields();
      allow delete: if isSignedIn() && isAdmin();
    }

    // Per-worker assigned orders mirror. Use a trusted server/Cloud Function to
    // copy/keep in sync assignments from /orders or /users/{uid}/orders into
    // /workers/{workerId}/orders so workers can safely list their assignments.
    match /workers/{workerId}/orders/{orderId} {
      // Workers (and admins) can list/get their assigned orders here.
      allow get, list: if isSignedIn() && (isAdmin() || request.auth.uid == workerId);

      // Allow updates by admin, or by the assigned worker with the same
      // limited status transitions and no server-managed field modifications.
      allow update: if isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (
          request.auth.uid == workerId
          && noServerFields()
          && (
            ( 'status' in request.resource.data && (
                request.resource.data.status in ['accepted', 'on_my_way', 'arrived', 'in_progress', 'paused', 'completed']
                && resource.data.status != 'completed'
              ) && request.resource.data.workerId == resource.data.workerId)
            || ( !('status' in request.resource.data) )
          )
        )
      );

      // Creation/deletion should be performed only by admin/trusted backend.
      allow create, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // services collection
    // -----------------------
    match /services/{serviceId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // top-level orders collection
    // -----------------------
    match /orders/{orderId} {
      allow get: if isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        || (resource.data.orderOwner == request.auth.uid)
        || (resource.data.userId == request.auth.uid)
        || (isWorker() && (resource.data.workerId == request.auth.uid || resource.data.status == 'pending'))
      );

      allow list: if isSignedIn() && (
        // Top-level orders listing is restricted to admins only. Regular users
        // must list their orders from `users/{uid}/orders` to avoid exposing
        // other users' orders. This also avoids using unsupported request.query.where().
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        // Allow workers to query top-level orders filtered by workerId==auth.uid
        || (isWorker() && resource.data.workerId == request.auth.uid)
      );

      allow create: if isSignedIn() && noServerFields() && ('items' in request.resource.data) && ('totalAmount' in request.resource.data);

      allow update: if isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
        || ((resource.data.orderOwner == request.auth.uid || resource.data.orderOwner == request.auth.token.phone_number)
            && !( 'workerId' in request.resource.data )
            && !( 'status' in request.resource.data )
            && noServerFields())
        || (
          // Allow assigned worker to update top-level order even if `isWorker()` is false
          resource.data.workerId == request.auth.uid
          && noServerFields()
          && (
            ( 'status' in request.resource.data && (
                request.resource.data.status in ['accepted', 'on_my_way', 'arrived', 'in_progress', 'paused', 'completed']
                && resource.data.status != 'completed'
              ) && request.resource.data.workerId == resource.data.workerId)
            || ( !('status' in request.resource.data) && !('workerId' in request.resource.data) )
          )
        )
        // Narrow fallback: allow assigned worker to perform a minimal, safe status-only update
        // even if other checks fail â€” only for the exact fields below and permitted values.
        || (
          isSignedIn()
          && resource.data.workerId == request.auth.uid
          // allow updatedAt as well (client may send serverTimestamp)
          // Accept either payloads that include workerId or that omit it (status-only)
          && (
            request.resource.data.keys().hasOnly(['status','orderStatus','workerId','updatedAt'])
            || request.resource.data.keys().hasOnly(['status','orderStatus','updatedAt'])
          )
          // if workerId is provided, ensure it matches the existing value
          && ( !('workerId' in request.resource.data) || request.resource.data.workerId == resource.data.workerId )
          && request.resource.data.status in ['accepted', 'on_my_way', 'arrived', 'in_progress', 'paused', 'completed']
          && resource.data.status != 'completed'
          // ensure updatedAt is either not written or is a server timestamp or unchanged
          && allowedServerTimestamp('updatedAt')
        )
      );

      allow delete: if isSignedIn() && (
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        || (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
      );
    }

    // -----------------------
    // bookings, payments, offers, admins, audit_logs, etc.
    // replicate admin/owner semantics similar to above.
    // -----------------------
    match /bookings/{bookingId} {
      allow create: if isSignedIn() && noServerFields() && (
        request.resource.data.orderOwner == request.auth.uid
        || request.resource.data.userId == request.auth.uid
        || (request.auth.token.phone_number != null && (request.resource.data.orderOwner == request.auth.token.phone_number || request.resource.data.userId == request.auth.token.phone_number))
      );

      // Use resource.data (existing document) for reads.
      allow get: if isSignedIn() && (
        isAdmin()
        || resource.data.orderOwner == request.auth.uid
        || resource.data.userId == request.auth.uid
        || (request.auth.token.phone_number != null && (resource.data.orderOwner == request.auth.token.phone_number || resource.data.userId == request.auth.token.phone_number))
      );
      // Restrict listing bookings at top-level to admins; users should list their
      // bookings via a per-user subcollection if available.
      allow list: if isSignedIn() && isAdmin();
      // For updates, check ownership on the existing document (resource.data)
      // and still require noServerFields() on the incoming data.
      allow update: if isSignedIn() && (
        isAdmin()
        || (
          (resource.data.orderOwner == request.auth.uid
           || resource.data.userId == request.auth.uid
           || (request.auth.token.phone_number != null && (resource.data.orderOwner == request.auth.token.phone_number || resource.data.userId == request.auth.token.phone_number))
          )
          && noServerFields()
        )
      );
      allow delete: if isSignedIn() && isAdmin();
    }

    match /offers/{offerId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    match /payments/{paymentId} {
      allow read: if isSignedIn() && (isAdmin() || (resource.data.orderOwner == request.auth.uid) || (resource.data.userId == request.auth.uid) || (request.auth.token.phone_number != null && (resource.data.userId == request.auth.token.phone_number || resource.data.orderOwner == request.auth.token.phone_number)));
      allow create: if isSignedIn() && noServerFields() && ('amount' in request.resource.data || 'totalAmount' in request.resource.data);
      allow update: if isSignedIn() && (isAdmin() || ((resource.data.userId == request.auth.uid || resource.data.orderOwner == request.auth.uid) && noServerFields()));
      allow delete: if isSignedIn() && isAdmin();
    }

    match /admins/{adminId} {
      allow read: if isSignedIn() && isAdmin();
      allow create: if isSignedIn() && (isAdmin() || (request.auth.uid == adminId && exists(/databases/$(database)/documents/users/$(adminId)) && get(/databases/$(database)/documents/users/$(adminId)).data.role == 'admin'));
      allow update, delete: if isSignedIn() && isAdmin();
    }

    match /audit_logs/{logId} {
      allow read, create, update, delete: if isSignedIn() && isAdmin();
    }

    // Deny by default
    match /{document=**} {
      allow read, write: if false;
    }

    // Generic match to allow collectionGroup queries on any `orders` subcollection
    match /{path=**}/orders/{orderId} {
      allow get: if isSignedIn() && (
        isAdmin()
        || resource.data.orderOwner == request.auth.uid
        || resource.data.userId == request.auth.uid
        || (isWorker() && (resource.data.workerId == request.auth.uid || resource.data.status == 'pending'))
      );

      // Allow listing via collectionGroup only for admins or workers when the
      // returned documents are assigned to the worker (the query must include
      // where('workerId', '==', request.auth.uid) for this to be secure and
      // supported by the rules engine).
      allow list: if isSignedIn() && (
        isAdmin()
        || (isWorker() && resource.data.workerId == request.auth.uid)
      );
    }
  }
}
