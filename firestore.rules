/// last updated: 2025-10-16

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -----------------------
    // Helper functions
    // -----------------------
    function isSignedIn() {
      return request.auth != null;
    }

    // Matches a document id that may be either the Firebase UID or the user's phone number
    // Many parts of the app may write user docs keyed by phone number (e.g., +919999...) or by UID.
    // This helper returns true if the provided id matches the current authenticated identity
    // using either `request.auth.uid` or `request.auth.token.phone_number` when available.
    function matchesAuthId(id) {
      return isSignedIn() && (
        request.auth.uid == id
        || (request.auth.token.phone_number != null && request.auth.token.phone_number == id)
      );
    }

    // Robust admin detection: prefer custom claims, admins marker, or the role stored
    // on the user's document. Try both UID and phone-number document ids for the users doc.
    function isAdmin() {
      return isSignedIn() && (
        // Custom claim on the token (recommended server-side approach)
        (request.auth.token != null && (request.auth.token.admin == true || request.auth.token.role == 'admin'))
        // Admins collection marker
        || exists(/databases/$(database)/documents/admins/$(request.auth.uid))
        // Check users document for role == 'admin' using UID or phone-number keyed doc
        || (
            (exists(/databases/$(database)/documents/users/$(request.auth.uid))
              && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role is string
              && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role.matches('(?i).*\\badmin\\b.*'))
           )
        || (
            (request.auth.token.phone_number != null)
            && exists(/databases/$(database)/documents/users/$(request.auth.token.phone_number))
            && get(/databases/$(database)/documents/users/$(request.auth.token.phone_number)).data.role is string
            && get(/databases/$(database)/documents/users/$(request.auth.token.phone_number)).data.role.matches('(?i).*\\badmin\\b.*')
          )
      );
    }

    function isWorker() {
      return isSignedIn() && (
        exists(/databases/$(database)/documents/workers/$(request.auth.uid))
        || (request.auth.token != null && request.auth.token.role == 'worker')
      );
    }

    // Owner check: document owner id may be uid or phone-number
    function isOwner(userId) {
      return matchesAuthId(userId);
    }

    // Helper: allow a timestamp field only if absent or equal to server request.time
    function allowedServerTimestamp(fieldName) {
      return !(fieldName in request.resource.data) || request.resource.data[fieldName] == request.time;
    }

    function noServerFields() {
      return !('orderNumber' in request.resource.data)
             && !('assignmentHistory' in request.resource.data)
             && !('paymentRef' in request.resource.data)
             && allowedServerTimestamp('createdAt')
             && allowedServerTimestamp('updatedAt')
             && !('onboardedAt' in request.resource.data);
    }

    function workerAllowedStatusTransition(old, new) {
      return (old == 'assigned' && new == 'accepted')
             || (old == 'accepted' && new == 'in_progress')
             || (old == 'in_progress' && new == 'completed');
    }

    // -----------------------
    // users collection
    // -----------------------
    match /users/{userId} {
      // Create: user may create their own profile. Disallow client from setting server-only
      // fields. Allow role to be omitted, 'user' or 'worker' to match app registration flow.
      allow create: if isSignedIn()
                    && matchesAuthId(userId)
                    && (
                        !( 'role' in request.resource.data )
                        || request.resource.data.role == 'user'
                        || request.resource.data.role == 'worker'
                       )
                    && noServerFields();

      // Read: owner or admin
      allow read: if isSignedIn() && (isOwner(userId) || isAdmin());

      // Update: admin can update anything. Owner can update but cannot change `role` value
      // (must keep the same value) and cannot set server-only fields.
      allow update: if isSignedIn() && (
                      isAdmin()
                      || (
                          isOwner(userId)
                          && ( !('role' in request.resource.data) || request.resource.data.role == resource.data.role )
                          && noServerFields()
                        )
                    );

      // Delete: owner or admin
      allow delete: if isSignedIn() && (isOwner(userId) || isAdmin());

      // cart subcollection
      match /cart/{cartId} {
        // cart documents belong to the parent user document, so use parent userId ownership check
        allow read, write: if isSignedIn() && (isOwner(userId) || isAdmin());
      }

      // orders subcollection (per-user orders)
      match /orders/{orderId} {
        // Create: only owner, must not set server-managed fields, and require only safe initial status
        allow create: if isSignedIn()
                        && isOwner(userId)
                        && noServerFields()
                        && (
                            !('status' in request.resource.data)
                            || request.resource.data.status == 'pending'
                           )
                        && ('items' in request.resource.data)
                        && ('totalAmount' in request.resource.data);

        // Get: owner, admin, or worker only if order is relevant
        allow get: if isSignedIn() && (
                     isOwner(userId)
                     || isAdmin()
                     || (isWorker() && (
                          // worker can read if order is pending (in pool) or assigned to them
                          (resource.data.status == 'pending')
                          || (resource.data.workerId == request.auth.uid)
                        ))
                   );

        // List (query): admin or owner; worker allowed only with constrained query
        allow list: if isSignedIn() && (
                      isAdmin()
                      || isOwner(userId)
                      || (
                          isWorker()
                          // the client query must explicitly filter by the workerId == current worker OR status == 'pending'
                          && (
                               (request.query.where('workerId','==', request.auth.uid))
                               || (request.query.where('status','==', 'pending'))
                             )
                        )
                    );

        // Update: admin can update everything.
        // Owner may update only non-assignment, non-status fields.
        // Worker may update a few status transitions but only when they're the assigned worker.
        allow update: if isSignedIn() && (
                        isAdmin()
                        || (
                            isOwner(userId)
                            && // owner cannot change `workerId` or `status`
                            !( 'workerId' in request.resource.data )
                            && !( 'status' in request.resource.data )
                            && noServerFields()
                          )
                        || (
                            isWorker()
                            && resource.data.workerId == request.auth.uid
                            && noServerFields()
                            && (
                                // either worker is updating allowed status change, or updating only worker-local fields (not assignment)
                                ( 'status' in request.resource.data && workerAllowedStatusTransition(resource.data.status, request.resource.data.status) && request.resource.data.workerId == resource.data.workerId )
                                || ( !('status' in request.resource.data) && !('workerId' in request.resource.data) )
                              )
                          )
                      );

        // Delete: only admin
        allow delete: if isSignedIn() && isAdmin();
      }

      // bookings subcollection: per-user booking documents (created on checkout)
      match /bookings/{bookingId} {
        // Allow owner to create/read/update their bookings; admin can read/update/delete
        allow create: if isSignedIn() && isOwner(userId) && noServerFields();
        allow read: if isSignedIn() && (isOwner(userId) || isAdmin());
        allow update: if isSignedIn() && (isAdmin() || isOwner(userId)) && noServerFields();
        allow delete: if isSignedIn() && isAdmin();
      }

      // payments subcollection (per-user payments). Clients may write limited payment metadata
      // for UX (e.g., to show receipts). Prefer backend functions for authoritative records.
      match /payments/{paymentId} {
        // Owner can create and read their payments; admin can read all payments.
        allow create: if isSignedIn() && isOwner(userId) && noServerFields();
        allow read: if isSignedIn() && (isOwner(userId) || isAdmin());
        // Owner may update no-server fields only; admin may update everything.
        allow update: if isSignedIn() && (isAdmin() || (isOwner(userId) && noServerFields()));
        allow delete: if isSignedIn() && isAdmin();
      }
    }

    // -----------------------
    // top-level carts (alternate flow)
    // -----------------------
    match /carts/{cartId} {
      allow read, write: if isSignedIn() && (matchesAuthId(cartId) || isAdmin());
    }

    // -----------------------
    // workers collection
    // -----------------------
    match /workers/{workerId} {
      // create: worker themself or admin (initial registration)
      // Note: having a /workers/{uid} doc is treated as an authoritative worker marker.
      allow create: if isSignedIn() && (matchesAuthId(workerId) || isAdmin())
                    && noServerFields();

      // read: admin, any worker (directory), or the worker themself
      allow read: if isSignedIn() && (isAdmin() || isWorker() || matchesAuthId(workerId));

      // update: only the worker themself or admin; disallow client from editing server-only fields
      allow update: if isSignedIn() && (isAdmin() || matchesAuthId(workerId))
                    && noServerFields();

      allow delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // services collection
    // -----------------------
    match /services/{serviceId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // top-level orders collection
    // Admins need access to list and read orders; workers can read relevant orders.
    // NOTE: many client SDKs call top-level `orders` when creating/fetching. In some cases
    // the client wasn't including `orderOwner`/`userId` in the request payload which caused
    // strict rules below to reject the write. To be permissive for authenticated users while
    // still blocking server-managed fields, we allow any authenticated user to create a top-level
    // order (server fields are still guarded). Clients SHOULD include `orderOwner` or `userId`
    // set to the authenticated UID so rules can be more strict in production.
    // -----------------------
    match /orders/{orderId} {
      // Read single order: admin, owner, or relevant worker
      allow get: if isSignedIn() && (
        isAdmin()
        || (resource.data.orderOwner == request.auth.uid)
        || (resource.data.userId == request.auth.uid)
        || (isWorker() && (resource.data.workerId == request.auth.uid || resource.data.status == 'pending'))
      );

      // List (query): admin, or owner queries; workers allowed only on constrained queries
      // IMPORTANT: for non-admin users, client must attach a `where('orderOwner','==', uid)` or `where('userId','==', uid)` filter.
      allow list: if isSignedIn() && (
        isAdmin()
        || (request.query.where('orderOwner','==', request.auth.uid))
        || (request.query.where('userId','==', request.auth.uid))
        || (
          isWorker() && (
            (request.query.where('workerId','==', request.auth.uid))
            || (request.query.where('status','==', 'pending'))
          )
        )
      );

      // Create: allow any authenticated user to create a top-level order for convenience in dev,
      // but still block client from setting server-managed fields. Production apps should require
      // `orderOwner` or `userId` set to the authenticated UID before allowing create.
      allow create: if isSignedIn()
        && noServerFields()
        && ('items' in request.resource.data)
        && ('totalAmount' in request.resource.data);

      // Update: admin can update everything. Owner limited and worker allowed status transitions when assigned.
      allow update: if isSignedIn() && (
        isAdmin()
        || (
          (resource.data.orderOwner == request.auth.uid || resource.data.orderOwner == request.auth.token.phone_number)
          && !( 'workerId' in request.resource.data )
          && !( 'status' in request.resource.data )
          && noServerFields()
        )
        || (
          isWorker()
          && resource.data.workerId == request.auth.uid
          && noServerFields()
          && (
            ( 'status' in request.resource.data && workerAllowedStatusTransition(resource.data.status, request.resource.data.status) && request.resource.data.workerId == resource.data.workerId )
            || ( !('status' in request.resource.data) && !('workerId' in request.resource.data) )
          )
        )
      );

      // Delete: only admin
      allow delete: if isSignedIn() && isAdmin();
    }

    // ------------------------------------------------------------------
    // Wildcard match for any orders subcollection.
    // This helps collectionGroup('orders') queries succeed when the caller
    // is an admin. Some SDKs perform collectionGroup queries which match
    // different /{parent}/orders/{orderId} paths; explicitly allowing admin
    // list/get here avoids PERMISSION_DENIED for admins when performing
    // collectionGroup queries across users/*/orders.
    match /{anyPath=**}/orders/{orderId} {
      // Admins can read/list any order document regardless of the parent path.
      allow get: if isSignedIn() && isAdmin();
      allow list: if isSignedIn() && isAdmin();

      // Admins can update/delete as well through this wildcard path.
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // bookings collection (top-level)
    // Clients may create bookings owned by themselves; admins can manage all bookings.
    // -----------------------
    match /bookings/{bookingId} {
      // Create: owner may create booking with no server-only fields
      allow create: if isSignedIn() && noServerFields() && (
        request.resource.data.orderOwner == request.auth.uid
        || request.resource.data.userId == request.auth.uid
        || (request.auth.token.phone_number != null && (request.resource.data.orderOwner == request.auth.token.phone_number || request.resource.data.userId == request.auth.token.phone_number))
      );

      // Read: owner or admin
      allow get: if isSignedIn() && (
        isAdmin() || request.resource.data.orderOwner == request.auth.uid || request.resource.data.userId == request.auth.uid
      );

      // List: owner or admin (owner queries should filter by orderOwner)
      allow list: if isSignedIn() && (
        isAdmin() || request.query.where('orderOwner','==', request.auth.uid)
      );

      // Update: owner can update non-server fields; admin can update all
      allow update: if isSignedIn() && (isAdmin() || ((request.resource.data.orderOwner == request.auth.uid || request.resource.data.userId == request.auth.uid) && noServerFields()));

      // Delete: only admin
      allow delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // offers collection
    // -----------------------
    match /offers/{offerId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // payments collection — CLIENTS SHOULD NOT WRITE HERE (top-level)
    // Prefer Cloud Functions (admin SDK) to write payment records. However the app uses
    // two flows: 1) per-user payments under users/{uid}/payments and 2) top-level payments.
    // To avoid permission-denied during checkout, allow authenticated users to write limited
    // payment metadata here (still disallow server-only fields). In production consider moving
    // authoritative payment writes to a trusted function.
    // -----------------------
    match /payments/{paymentId} {
      // reads: admin, or owner of associated order (if you store orderOwner)
      allow read: if isSignedIn() && (
        isAdmin()
        || (resource.data.orderOwner == request.auth.uid)
        || (resource.data.userId == request.auth.uid)
        || (request.auth.token.phone_number != null && (resource.data.userId == request.auth.token.phone_number || resource.data.orderOwner == request.auth.token.phone_number))
      );

      // Allow limited client-side creation for payments when the authenticated user
      // is the owner of the payment (userId or orderOwner) and they don't set server-managed fields.
      // Relaxed here to allow authenticated users to create payment metadata if they supply
      // minimal required fields (amount, method). Recommend client to set `userId` or `orderOwner`.
      allow create: if isSignedIn() && noServerFields() && ('amount' in request.resource.data || 'totalAmount' in request.resource.data);

      // Owner may update no-server fields only; admin may update everything.
      allow update: if isSignedIn() && (isAdmin() || ( (request.resource.data.userId == request.auth.uid || request.resource.data.orderOwner == request.auth.uid) && noServerFields()));
      allow delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // admins collection — admin-only (but allow self-create if users/{uid}.role == 'admin')
    // -----------------------
    match /admins/{adminId} {
      // reading admin list is admin-only
      allow read: if isSignedIn() && isAdmin();
      // Allow create in two cases:
      // 1. Standard admin (has admin claim or existing admins doc) -> isAdmin()
      // 2. Self-create at registration time: the authenticated user writes /admins/uid
      //    AND their users/{uid} document exists and has role containing 'admin'.
      allow create: if isSignedIn() && (
        isAdmin()
        || (
          request.auth.uid == adminId
          && (exists(/databases/$(database)/documents/users/$(adminId))
              && (get(/databases/$(database)/documents/users/$(adminId)).data.role is string)
              && get(/databases/$(database)/documents/users/$(adminId)).data.role.matches('(?i).*\\badmin\\b.*'))
          || (
            request.auth.token.phone_number != null
            && exists(/databases/$(database)/documents/users/$(request.auth.token.phone_number))
            && (get(/databases/$(database)/documents/users/$(request.auth.token.phone_number)).data.role is string)
            && get(/databases/$(database)/documents/users/$(request.auth.token.phone_number)).data.role.matches('(?i).*\\badmin\\b.*')
          )

          )
        )
      );

      // Updates and deletes should remain admin-only to avoid privilege escalation.
      allow update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // audit_logs — admin can read; client writes discouraged
    // Cloud Functions (admin SDK) should write audit logs.
    // -----------------------
    match /audit_logs/{logId} {
      allow read: if isSignedIn() && isAdmin();
      // allow admin client writes for convenience but ideally Cloud Functions write logs
      allow create: if isSignedIn() && isAdmin();
      allow update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // Default: deny everything else
    // -----------------------
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
