/// last updated: 2025-10-14

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -----------------------
    // Helper functions
    // -----------------------
    function isSignedIn() {
      return request.auth != null;
    }

    // Use the `admins` collection (or custom claims) to determine admin status.
    function isAdmin() {
      // Accept either a server-side 'admins' doc, an 'admin' custom claim,
      // or a 'role' custom claim set to 'admin'. Also accept a users/{uid}.role
      // field set to 'admin' (any case) so that admin detection works even
      // without custom claims or a separate admins doc.
      return isSignedIn() && (
        // explicit admin custom claim flag
        (request.auth.token != null && request.auth.token.admin == true)
        // or a 'role' custom claim set to 'admin'
        || (request.auth.token != null && request.auth.token.role == 'admin')
        // or an entry in /admins/{uid}
        || exists(/databases/$(database)/documents/admins/$(request.auth.uid))
        // or the users/{uid}.role field contains 'admin' (case-insensitive)
        || (
             exists(/databases/$(database)/documents/users/$(request.auth.uid))
             && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role.matches('(?i)^admin$')
           )
      );
    }

    // Worker detection: consider a user a worker if either:
    // - there's an explicit admin-created /workers/{uid} doc, OR
    // - the users/{uid} document has role == 'worker'
    // This keeps the rules compatible with client-side registration that writes users/{uid}.role
    function isWorker() {
      // Guard the users doc read with an exists() check to avoid runtime errors
      // when the users document does not yet exist.
      return isSignedIn() && (
        exists(/databases/$(database)/documents/workers/$(request.auth.uid))
        || (
             exists(/databases/$(database)/documents/users/$(request.auth.uid))
             && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'worker'
           )
      );
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Helper: allow a timestamp field only if absent or equal to server request.time
    function allowedServerTimestamp(fieldName) {
      return !(fieldName in request.resource.data) || request.resource.data[fieldName] == request.time;
    }

    // Shared helper: forbid client from setting server-only fields except when they are
    // legitimate serverTimestamp sent via FieldValue.serverTimestamp() (which becomes request.time).
    function noServerFields() {
      // orderNumber, assignmentHistory, paymentRef, onboardedAt must not be set by clients.
      return !('orderNumber' in request.resource.data)
             && !('assignmentHistory' in request.resource.data)
             && !('paymentRef' in request.resource.data)
             && allowedServerTimestamp('createdAt')
             && allowedServerTimestamp('updatedAt')
             && !('onboardedAt' in request.resource.data);
    }

    // Worker allowed status transition helper (lifted to top-level so it can be reused by top-level orders)
    function workerAllowedStatusTransition(old, new) {
      return (old == 'assigned' && new == 'accepted')
             || (old == 'accepted' && new == 'in_progress')
             || (old == 'in_progress' && new == 'completed');
    }

    // -----------------------
    // users collection
    // -----------------------
    match /users/{userId} {
      // Create: user may create their own profile. Disallow client from setting server-only
      // fields. Allow role to be omitted, 'user' or 'worker' to match app registration flow.
      allow create: if isSignedIn()
                    && request.auth.uid == userId
                    && (
                        !( 'role' in request.resource.data )
                        || request.resource.data.role == 'user'
                        || request.resource.data.role == 'worker'
                       )
                    && noServerFields();

      // Read: owner or admin
      allow read: if isSignedIn() && (isOwner(userId) || isAdmin());

      // Update: admin can update anything. Owner can update but cannot change `role` value
      // (must keep the same value) and cannot set server-only fields.
      allow update: if isSignedIn() && (
                      isAdmin()
                      || (
                          isOwner(userId)
                          && ( !('role' in request.resource.data) || request.resource.data.role == resource.data.role )
                          && noServerFields()
                        )
                    );

      // Delete: owner or admin
      allow delete: if isSignedIn() && (isOwner(userId) || isAdmin());

      // cart subcollection
      match /cart/{cartId} {
        allow read, write: if isSignedIn() && (isOwner(userId) || isAdmin());
      }

      // orders subcollection (per-user orders)
      match /orders/{orderId} {
        // Create: only owner, must not set server-managed fields, and require only safe initial status
        allow create: if isSignedIn()
                        && isOwner(userId)
                        && noServerFields()
                        && (
                            !('status' in request.resource.data)
                            || request.resource.data.status == 'pending'
                           )
                        && ('items' in request.resource.data)
                        && ('totalAmount' in request.resource.data);

        // Get: owner, admin, or worker only if order is relevant
        allow get: if isSignedIn() && (
                     isOwner(userId)
                     || isAdmin()
                     || (isWorker() && (
                          // worker can read if order is pending (in pool) or assigned to them
                          (resource.data.status == 'pending')
                          || (resource.data.workerId == request.auth.uid)
                        ))
                   );

        // List (query): admin or owner; worker allowed only with constrained query
        allow list: if isSignedIn() && (
                      isAdmin()
                      || isOwner(userId)
                      || (
                          isWorker()
                          // the client query must explicitly filter by the workerId == current worker OR status == 'pending'
                          && (
                               (request.query.where('workerId','==', request.auth.uid))
                               || (request.query.where('status','==', 'pending'))
                             )
                        )
                    );

        // Helper: valid worker transitions for worker role
        function workerAllowedStatusTransition(old, new) {
          return (old == 'assigned' && new == 'accepted')
                 || (old == 'accepted' && new == 'in_progress')
                 || (old == 'in_progress' && new == 'completed');
        }

        // Update: admin can update everything.
        // Owner may update only non-assignment, non-status fields.
        // Worker may update a few status transitions but only when they're the assigned worker.
        allow update: if isSignedIn() && (
                        isAdmin()
                        || (
                            isOwner(userId)
                            && // owner cannot change `workerId` or `status`
                            !( 'workerId' in request.resource.data )
                            && !( 'status' in request.resource.data )
                            && noServerFields()
                          )
                        || (
                            isWorker()
                            && resource.data.workerId == request.auth.uid
                            && noServerFields()
                            && (
                                // either worker is updating allowed status change, or updating only worker-local fields (not assignment)
                                ( 'status' in request.resource.data && workerAllowedStatusTransition(resource.data.status, request.resource.data.status) && request.resource.data.workerId == resource.data.workerId )
                                || ( !('status' in request.resource.data) && !('workerId' in request.resource.data) )
                              )
                          )
                      );

        // Delete: only admin
        allow delete: if isSignedIn() && isAdmin();
      }
    }

    // -----------------------
    // top-level carts (alternate flow)
    // -----------------------
    match /carts/{cartId} {
      allow read, write: if isSignedIn() && (request.auth.uid == cartId || isAdmin());
    }

    // -----------------------
    // workers collection
    // -----------------------
    match /workers/{workerId} {
      // create: worker themself or admin (initial registration)
      // Note: having a /workers/{uid} doc is treated as an authoritative worker marker.
      allow create: if isSignedIn() && (request.auth.uid == workerId || isAdmin())
                    && noServerFields();

      // read: admin, any worker (directory), or the worker themself
      allow read: if isSignedIn() && (isAdmin() || isWorker() || request.auth.uid == workerId);

      // update: only the worker themself or admin; disallow client from editing server-only fields
      allow update: if isSignedIn() && (isAdmin() || request.auth.uid == workerId)
                    && noServerFields();

      allow delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // services collection
    // -----------------------
    match /services/{serviceId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // top-level orders collection
    // Admins need access to list and read orders; workers can read relevant orders.
    // -----------------------
    match /orders/{orderId} {
      // Read single order: admin, owner, or relevant worker
      allow get: if isSignedIn() && (
        isAdmin()
        || (resource.data.orderOwner == request.auth.uid)
        || (isWorker() && (resource.data.workerId == request.auth.uid || resource.data.status == 'pending'))
      );

      // List (query): admin, or owner queries; workers allowed only on constrained queries
      allow list: if isSignedIn() && (
        isAdmin()
        || (request.query.where('orderOwner','==', request.auth.uid))
        || (
          isWorker() && (
            (request.query.where('workerId','==', request.auth.uid))
            || (request.query.where('status','==', 'pending'))
          )
        )
      );

      // Create: owner can create a top-level order if they set themselves as orderOwner (app may still use users/{uid}/orders)
      allow create: if isSignedIn()
        && (request.resource.data.orderOwner == request.auth.uid)
        && noServerFields()
        && ('items' in request.resource.data)
        && ('totalAmount' in request.resource.data);

      // Update: admin can update everything. Owner limited and worker allowed status transitions when assigned.
      allow update: if isSignedIn() && (
        isAdmin()
        || (
          (resource.data.orderOwner == request.auth.uid)
          && !( 'workerId' in request.resource.data )
          && !( 'status' in request.resource.data )
          && noServerFields()
        )
        || (
          isWorker()
          && resource.data.workerId == request.auth.uid
          && noServerFields()
          && (
            ( 'status' in request.resource.data && workerAllowedStatusTransition(resource.data.status, request.resource.data.status) && request.resource.data.workerId == resource.data.workerId )
            || ( !('status' in request.resource.data) && !('workerId' in request.resource.data) )
          )
        )
      );

      // Delete: only admin
      allow delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // offers collection
    // -----------------------
    match /offers/{offerId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // payments collection — CLIENTS SHOULD NOT WRITE HERE
    // Prefer Cloud Functions (admin SDK) to write payment records.
    // -----------------------
    match /payments/{paymentId} {
      // reads: admin, or owner of associated order (if you store orderOwner)
      allow read: if isSignedIn() && (isAdmin() || (resource.data.orderOwner == request.auth.uid));

      // deny client writes — Cloud Functions (admin SDK) can create/update payments
      allow create, update, delete: if false;
    }

    // -----------------------
    // admins collection — admin-only
    // -----------------------
    match /admins/{adminId} {
      // reading admin list is admin-only
      allow read: if isSignedIn() && isAdmin();
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // audit_logs — admin can read; client writes discouraged
    // Cloud Functions (admin SDK) should write audit logs.
    // -----------------------
    match /audit_logs/{logId} {
      allow read: if isSignedIn() && isAdmin();
      // allow admin client writes for convenience but ideally Cloud Functions write logs
      allow create: if isSignedIn() && isAdmin();
      allow update, delete: if isSignedIn() && isAdmin();
    }

    // -----------------------
    // Default: deny everything else
    // -----------------------
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
